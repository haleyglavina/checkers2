{"ast":null,"code":"// Define tiles with no checkers on them\nexport const emptyBoard = boardSize => {\n  let tile = [];\n\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      tile.push({\n        i,\n        j,\n        hasChecker: null\n      });\n    }\n  }\n\n  return tile;\n}; // Define tiles with start of game checkers arrangement\n\nexport const resetBoard = boardSize => {\n  let tile = [];\n\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      if (i <= boardSize / 3 && !getColor([i, j])) tile.push({\n        i,\n        j,\n        hasChecker: 1,\n        king: false\n      });else if (i >= boardSize - boardSize / 3 - 1 && !getColor([i, j])) tile.push({\n        i,\n        j,\n        hasChecker: 2,\n        king: false\n      });else tile.push({\n        i,\n        j,\n        hasChecker: null,\n        king: false\n      });\n    }\n  }\n\n  return tile;\n}; // Determines what color a tile will be\n\nexport const getColor = coord => {\n  let i = coord[0];\n  let j = coord[1];\n  if ((i % 2 === 0 && j % 2 === 0) | (i % 2 === 1 && j % 2 === 1)) return 0;\n  return 1;\n}; // Check if proposed checker movement is legal\n\nconst isMoveValid = (tiles, oldCoord, newCoord, boardSize, score, updateScore) => {\n  // oldCoord must not equal new coord\n  if (oldCoord[0] === newCoord[0] & oldCoord[1] === newCoord[1]) return false; // oldCoord must contain a checker\n\n  if (!tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker) return false; // newCoord must contain no checker\n\n  if (tiles[newCoord[0] * boardSize + newCoord[1]].hasChecker) return false; // SINGLES\n  // Moving a single in its forward direction by 1 is legal\n\n  if (!tiles[oldCoord[0] * boardSize + oldCoord[1]].king) {\n    let fwdDirection = tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker;\n    let singleiChangeValid = fwdDirection === 1 ? newCoord[0] === oldCoord[0] + 1 : newCoord[0] === oldCoord[0] - 1;\n    let singlejChangeValid = newCoord[1] === oldCoord[1] + 1 || newCoord[1] === oldCoord[1] - 1;\n    if (!(singleiChangeValid & singlejChangeValid)) return false;\n  } // KINGS\n  // Moving a king in its forward or backward direction by 1 is legal\n  else {\n    singleiChangeValid = newCoord[0] === oldCoord[0] + 1 || newCoord[0] === oldCoord[0] - 1;\n    singlejChangeValid = newCoord[1] === oldCoord[1] + 1 || newCoord[1] === oldCoord[1] - 1;\n    if (!(singleiChangeValid & singlejChangeValid)) return false;\n  }\n\n  return true;\n}; // Check if proposed checker move larger than an adjacent diagonal is legal\n\n\nconst isBigMoveValid = () => {\n  // SINGLES\n  if (!tiles[oldCoord[0] * boardSize + oldCoord[1]].king) {\n    // // Moving a single in its forward direction by 1 is legal\n    // let fwdDirection = tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker;\n    // let singleiChangeValid = fwdDirection === 1 ? (newCoord[0] === (oldCoord[0] + 1)) : (newCoord[0] === (oldCoord[0] - 1));\n    // let singlejChangeValid = ((newCoord[1] === (oldCoord[1] + 1)) || (newCoord[1] === (oldCoord[1] - 1)));\n    // console.log(\"fwdDirection: \", fwdDirection);\n    // console.log(\"iChangeValid:\", iChangeValid);\n    // console.log(\"jChangeValid:\", jChangeValid);\n    // Moving a single in its forward direction by 2 is legal if it captures opponent\n    let kingiChangeValid = fwdDirection === 1 ? newCoord[0] === oldCoord[0] + 2 : newCoord[0] === oldCoord[0] - 2;\n    let kingjChangeValid = newCoord[1] === oldCoord[1] + 2 || newCoord[1] === oldCoord[1] - 2;\n    let opponentCoord = [Math.abs(oldCoord[0] - newCoord[0]), Math.abs(oldCoord[1] - newCoord[1])];\n    let capturesOpponent = fwdDirection === 1 ? tiles[opponentCoord[0] * boardSize + opponentCoord[1]].hasChecker === 2 : tiles[opponentCoord[0] * boardSize + opponentCoord[1]].hasChecker === 1; // console.log(\"king i change valid: \", kingiChangeValid);\n    // console.log(\"king j change valid: \", kingjChangeValid);\n    // console.log(\"opponent coord: \", opponentCoord);\n    // console.log(\"captures opponent: \", capturesOpponent);\n\n    if (!(singleiChangeValid & singlejChangeValid) & !(kingiChangeValid & kingjChangeValid & capturesOpponent)) return false;\n  } // KINGS\n  // checker can move backward if its a king\n\n}; // Removes an opponent's checker from the board\n\n\nconst moveCapturesOpponent = () => {\n  // remove opponent\n  tiles[opponentCoord] = {\n    i: oldCoord[0],\n    j: oldCoord[1],\n    hasChecker: null,\n    king: false\n  }; // increment point\n}; // Moves a checker from oldCoord to newCoord, returns updated tiles array\n\n\nexport const moveChecker = (tiles, oldCoord, newCoord, boardSize, score, updateScore) => {\n  if (!isMoveValid(tiles, oldCoord, newCoord, boardSize)) return tiles; // console.log(\"tiles before: \", tiles);\n\n  tiles[newCoord[0] * boardSize + newCoord[1]] = {\n    i: newCoord[0],\n    j: newCoord[1],\n    hasChecker: tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker,\n    king: tiles[oldCoord[0] * boardSize + oldCoord[1]].king\n  };\n  tiles[oldCoord[0] * boardSize + oldCoord[1]] = {\n    i: oldCoord[0],\n    j: oldCoord[1],\n    hasChecker: null,\n    king: false\n  }; // console.log(\"tiles after: \", tiles);\n\n  return tiles;\n};","map":{"version":3,"sources":["/Users/haleyglavina/Desktop/code/checkers2/src/utils/BoardFunctions.js"],"names":["emptyBoard","boardSize","tile","i","j","push","hasChecker","resetBoard","getColor","king","coord","isMoveValid","tiles","oldCoord","newCoord","score","updateScore","fwdDirection","singleiChangeValid","singlejChangeValid","isBigMoveValid","kingiChangeValid","kingjChangeValid","opponentCoord","Math","abs","capturesOpponent","moveCapturesOpponent","moveChecker"],"mappings":"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","sourcesContent":["// Define tiles with no checkers on them\nexport const emptyBoard = (boardSize) => {\n  let tile = []\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      tile.push({i, j, hasChecker: null});\n    }\n  }\n  return tile;\n}\n\n// Define tiles with start of game checkers arrangement\nexport const resetBoard = (boardSize) => {\n  let tile = []\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      if (i <= (boardSize / 3) && !getColor([i, j]))\n        tile.push({i, j, hasChecker: 1, king: false});\n      \n      else if (i >= (boardSize - (boardSize / 3) - 1) && !getColor([i, j])) \n        tile.push({i, j, hasChecker: 2, king: false});\n      \n      else \n        tile.push({i, j, hasChecker: null, king: false});\n    }\n  }\n  return tile;\n}\n\n// Determines what color a tile will be\nexport const getColor = (coord) => {\n  let i = coord[0]\n  let j = coord[1]\n\n  if (((i % 2 === 0) && (j % 2 === 0)) | ((i % 2 === 1) && (j % 2 === 1)))\n    return 0;\n  return 1;\n}\n\n// Check if proposed checker movement is legal\nconst isMoveValid = (tiles, oldCoord, newCoord, boardSize, score, updateScore) => {\n  // oldCoord must not equal new coord\n    if ((oldCoord[0] === newCoord[0]) & (oldCoord[1] === newCoord[1]))\n      return false;\n\n  // oldCoord must contain a checker\n  if (!tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker)\n    return false;\n\n  // newCoord must contain no checker\n  if (tiles[(newCoord[0] * boardSize) + newCoord[1]].hasChecker)\n    return false;\n\n  // SINGLES\n  // Moving a single in its forward direction by 1 is legal\n  if (!tiles[(oldCoord[0] * boardSize) + oldCoord[1]].king) {\n    let fwdDirection = tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker;\n    let singleiChangeValid = fwdDirection === 1 ? (newCoord[0] === (oldCoord[0] + 1)) : (newCoord[0] === (oldCoord[0] - 1));\n    let singlejChangeValid = ((newCoord[1] === (oldCoord[1] + 1)) || (newCoord[1] === (oldCoord[1] - 1)));\n\n    if (!(singleiChangeValid & singlejChangeValid))\n      return false;\n\n  }\n\n  // KINGS\n  // Moving a king in its forward or backward direction by 1 is legal\n  else {\n    singleiChangeValid = ((newCoord[0] === (oldCoord[0] + 1)) || (newCoord[0] === (oldCoord[0] - 1)));\n    singlejChangeValid = ((newCoord[1] === (oldCoord[1] + 1)) || (newCoord[1] === (oldCoord[1] - 1)));\n\n    if (!(singleiChangeValid & singlejChangeValid))\n      return false;\n  }\n\n  \n\n  return true;\n}\n\n// Check if proposed checker move larger than an adjacent diagonal is legal\nconst isBigMoveValid = () => {\n\n  // SINGLES\n  if (!tiles[(oldCoord[0] * boardSize) + oldCoord[1]].king) {\n    // // Moving a single in its forward direction by 1 is legal\n    // let fwdDirection = tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker;\n    // let singleiChangeValid = fwdDirection === 1 ? (newCoord[0] === (oldCoord[0] + 1)) : (newCoord[0] === (oldCoord[0] - 1));\n    // let singlejChangeValid = ((newCoord[1] === (oldCoord[1] + 1)) || (newCoord[1] === (oldCoord[1] - 1)));\n\n    // console.log(\"fwdDirection: \", fwdDirection);\n    // console.log(\"iChangeValid:\", iChangeValid);\n    // console.log(\"jChangeValid:\", jChangeValid);\n\n    // Moving a single in its forward direction by 2 is legal if it captures opponent\n    let kingiChangeValid = fwdDirection === 1 ? (newCoord[0] === (oldCoord[0] + 2)) : (newCoord[0] === (oldCoord[0] - 2));\n    let kingjChangeValid = ((newCoord[1] === (oldCoord[1] + 2)) || (newCoord[1] === (oldCoord[1] - 2)));\n    let opponentCoord = [Math.abs((oldCoord[0] - newCoord[0])), Math.abs((oldCoord[1] - newCoord[1]))];\n    let capturesOpponent = fwdDirection === 1 ? (tiles[(opponentCoord[0] * boardSize) + opponentCoord[1]].hasChecker === 2) : (tiles[(opponentCoord[0] * boardSize) + opponentCoord[1]].hasChecker === 1);\n\n    // console.log(\"king i change valid: \", kingiChangeValid);\n    // console.log(\"king j change valid: \", kingjChangeValid);\n    // console.log(\"opponent coord: \", opponentCoord);\n    // console.log(\"captures opponent: \", capturesOpponent);\n\n    if (!(singleiChangeValid & singlejChangeValid) & !(kingiChangeValid & kingjChangeValid & capturesOpponent))\n      return false;\n    \n  }\n\n  // KINGS\n  // checker can move backward if its a king\n\n}\n\n// Removes an opponent's checker from the board\nconst moveCapturesOpponent = () => {\n\n    // remove opponent\n    tiles[opponentCoord] = {\n      i: oldCoord[0], \n      j: oldCoord[1], \n      hasChecker: null,\n      king: false\n    };\n  \n    // increment point\n\n}\n\n// Moves a checker from oldCoord to newCoord, returns updated tiles array\nexport const moveChecker = (tiles, oldCoord, newCoord, boardSize, score, updateScore) => {\n\n  if (!isMoveValid(tiles, oldCoord, newCoord, boardSize))\n    return tiles;\n  \n  \n  \n  \n    \n  // console.log(\"tiles before: \", tiles);\n\n  tiles[(newCoord[0] * boardSize) + newCoord[1]] = {\n    i: newCoord[0], \n    j: newCoord[1], \n    hasChecker: tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker,\n    king: tiles[(oldCoord[0] * boardSize) + oldCoord[1]].king\n  };\n\n  tiles[(oldCoord[0] * boardSize) + oldCoord[1]] = {\n    i: oldCoord[0], \n    j: oldCoord[1], \n    hasChecker: null,\n    king: false\n  };\n\n  // console.log(\"tiles after: \", tiles);\n  return tiles;\n}"]},"metadata":{},"sourceType":"module"}