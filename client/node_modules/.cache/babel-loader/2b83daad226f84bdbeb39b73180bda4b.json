{"ast":null,"code":"import { tileIndex } from './BoardFunctions';\n/*\n// Define tiles with no checkers on them\n*/\n\nexport const emptyBoard = boardSize => {\n  let tile = [];\n\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      tile.push({\n        i,\n        j,\n        hasChecker: null\n      });\n    }\n  }\n\n  return tile;\n};\n/*\n// Define tiles where p1 pawns remain and cant move, so p2 wins\n// Assumes a boardSize of 8\n*/\n\nexport const pawnCantMove = (i, j, boardSize) => {\n  let tiles = emptyBoard(8);\n  let p1Pawn = {\n    i,\n    j,\n    hasChecker: 1,\n    king: false\n  };\n  let p2Pawn = {\n    i,\n    j,\n    hasChecker: -1,\n    king: false\n  };\n  tiles[tileIndex(3, 3, 8)] = p1Pawn;\n  tiles[tileIndex(4, 2, 8)] = p2Pawn;\n  tiles[tileIndex(5, 1, 8)] = p2Pawn;\n  tiles[tileIndex(4, 4, 8)] = p2Pawn;\n  tiles[tileIndex(5, 5, 8)] = p2Pawn;\n};","map":{"version":3,"sources":["/Users/haleyglavina/Desktop/code/checkers2/client/src/utils/BoardTestSetup.js"],"names":["tileIndex","emptyBoard","boardSize","tile","i","j","push","hasChecker","pawnCantMove","tiles","p1Pawn","king","p2Pawn"],"mappings":"AAAA,SAASA,SAAT,QAA0B,kBAA1B;AAEA;AACA;AACA;;AACA,OAAO,MAAMC,UAAU,GAAIC,SAAD,IAAe;AACvC,MAAIC,IAAI,GAAG,EAAX;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAApB,EAA+BE,CAAC,EAAhC,EAAoC;AAClC,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAClC;AACAF,MAAAA,IAAI,CAACG,IAAL,CAAU;AAACF,QAAAA,CAAD;AAAIC,QAAAA,CAAJ;AAAOE,QAAAA,UAAU,EAAE;AAAnB,OAAV;AACD;AACF;;AACD,SAAOJ,IAAP;AACD,CATM;AAWP;AACA;AACA;AACA;;AACA,OAAO,MAAMK,YAAY,GAAG,CAACJ,CAAD,EAAIC,CAAJ,EAAOH,SAAP,KAAqB;AAC/C,MAAIO,KAAK,GAAGR,UAAU,CAAC,CAAD,CAAtB;AACA,MAAIS,MAAM,GAAG;AAACN,IAAAA,CAAD;AAAIC,IAAAA,CAAJ;AAAOE,IAAAA,UAAU,EAAE,CAAnB;AAAsBI,IAAAA,IAAI,EAAE;AAA5B,GAAb;AACA,MAAIC,MAAM,GAAG;AAACR,IAAAA,CAAD;AAAIC,IAAAA,CAAJ;AAAOE,IAAAA,UAAU,EAAE,CAAC,CAApB;AAAuBI,IAAAA,IAAI,EAAE;AAA7B,GAAb;AAEAF,EAAAA,KAAK,CAACT,SAAS,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV,CAAL,GAA0BU,MAA1B;AACAD,EAAAA,KAAK,CAACT,SAAS,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV,CAAL,GAA0BY,MAA1B;AACAH,EAAAA,KAAK,CAACT,SAAS,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV,CAAL,GAA0BY,MAA1B;AACAH,EAAAA,KAAK,CAACT,SAAS,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV,CAAL,GAA0BY,MAA1B;AACAH,EAAAA,KAAK,CAACT,SAAS,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV,CAAL,GAA0BY,MAA1B;AACD,CAVM","sourcesContent":["import { tileIndex } from './BoardFunctions';\n\n/*\n// Define tiles with no checkers on them\n*/\nexport const emptyBoard = (boardSize) => {\n  let tile = []\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      tile.push({i, j, hasChecker: null});\n    }\n  }\n  return tile;\n}\n\n/*\n// Define tiles where p1 pawns remain and cant move, so p2 wins\n// Assumes a boardSize of 8\n*/\nexport const pawnCantMove = (i, j, boardSize) => {\n  let tiles = emptyBoard(8);\n  let p1Pawn = {i, j, hasChecker: 1, king: false};\n  let p2Pawn = {i, j, hasChecker: -1, king: false};\n\n  tiles[tileIndex(3,3,8)] = p1Pawn;\n  tiles[tileIndex(4,2,8)] = p2Pawn;\n  tiles[tileIndex(5,1,8)] = p2Pawn;\n  tiles[tileIndex(4,4,8)] = p2Pawn;\n  tiles[tileIndex(5,5,8)] = p2Pawn;\n}"]},"metadata":{},"sourceType":"module"}