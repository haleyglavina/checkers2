{"ast":null,"code":"import { tileIndex } from './BoardFunctions';\n/*\n// Make pawn and king objects  \n*/\n\nconst makeP1Pawn = (i, j) => {\n  return {\n    i,\n    j,\n    hasChecker: 1,\n    king: false\n  };\n};\n\nconst makeP2Pawn = (i, j) => {\n  return {\n    i,\n    j,\n    hasChecker: -1,\n    king: false\n  };\n};\n\nconst makeP1King = (i, j) => {\n  return {\n    i,\n    j,\n    hasChecker: 1,\n    king: true\n  };\n};\n\nconst makeP2King = (i, j) => {\n  return {\n    i,\n    j,\n    hasChecker: -1,\n    king: true\n  };\n};\n/*\n// Define tiles with no checkers on them\n*/\n\n\nexport const emptyBoard = boardSize => {\n  let tile = [];\n\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      tile.push({\n        i,\n        j,\n        hasChecker: null\n      });\n    }\n  }\n\n  return tile;\n};\n/*\n// Define tiles where p1 pawns remain and cant move, so p2 wins\n// Assumes a boardSize of 8\n*/\n\nexport const pawnCantMove = (i, j) => {\n  let tiles = emptyBoard(8);\n  tiles[tileIndex(3, 3, 8)] = makeP1Pawn(3, 3);\n  tiles[tileIndex(4, 2, 8)] = makeP2Pawn(4, 2);\n  tiles[tileIndex(6, 0, 8)] = makeP2Pawn(6, 0);\n  tiles[tileIndex(4, 4, 8)] = makeP2Pawn(4, 4);\n  tiles[tileIndex(5, 5, 8)] = makeP2Pawn(5, 5);\n  return tiles;\n};","map":{"version":3,"sources":["/Users/haleyglavina/Desktop/code/checkers2/client/src/utils/BoardTestSetup.js"],"names":["tileIndex","makeP1Pawn","i","j","hasChecker","king","makeP2Pawn","makeP1King","makeP2King","emptyBoard","boardSize","tile","push","pawnCantMove","tiles"],"mappings":"AAAA,SAASA,SAAT,QAA0B,kBAA1B;AAEA;AACA;AACA;;AACA,MAAMC,UAAU,GAAG,CAACC,CAAD,EAAGC,CAAH,KAAS;AAC1B,SAAO;AAACD,IAAAA,CAAD;AAAIC,IAAAA,CAAJ;AAAOC,IAAAA,UAAU,EAAE,CAAnB;AAAsBC,IAAAA,IAAI,EAAE;AAA5B,GAAP;AACD,CAFD;;AAIA,MAAMC,UAAU,GAAG,CAACJ,CAAD,EAAGC,CAAH,KAAS;AAC1B,SAAO;AAACD,IAAAA,CAAD;AAAIC,IAAAA,CAAJ;AAAOC,IAAAA,UAAU,EAAE,CAAC,CAApB;AAAuBC,IAAAA,IAAI,EAAE;AAA7B,GAAP;AACD,CAFD;;AAIA,MAAME,UAAU,GAAG,CAACL,CAAD,EAAGC,CAAH,KAAS;AAC1B,SAAO;AAACD,IAAAA,CAAD;AAAIC,IAAAA,CAAJ;AAAOC,IAAAA,UAAU,EAAE,CAAnB;AAAsBC,IAAAA,IAAI,EAAE;AAA5B,GAAP;AACD,CAFD;;AAIA,MAAMG,UAAU,GAAG,CAACN,CAAD,EAAGC,CAAH,KAAS;AAC1B,SAAO;AAACD,IAAAA,CAAD;AAAIC,IAAAA,CAAJ;AAAOC,IAAAA,UAAU,EAAE,CAAC,CAApB;AAAuBC,IAAAA,IAAI,EAAE;AAA7B,GAAP;AACD,CAFD;AAIA;AACA;AACA;;;AACA,OAAO,MAAMI,UAAU,GAAIC,SAAD,IAAe;AACvC,MAAIC,IAAI,GAAG,EAAX;;AACA,OAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,SAApB,EAA+BR,CAAC,EAAhC,EAAoC;AAClC,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGO,SAApB,EAA+BP,CAAC,EAAhC,EAAoC;AAClC;AACAQ,MAAAA,IAAI,CAACC,IAAL,CAAU;AAACV,QAAAA,CAAD;AAAIC,QAAAA,CAAJ;AAAOC,QAAAA,UAAU,EAAE;AAAnB,OAAV;AACD;AACF;;AACD,SAAOO,IAAP;AACD,CATM;AAWP;AACA;AACA;AACA;;AACA,OAAO,MAAME,YAAY,GAAG,CAACX,CAAD,EAAIC,CAAJ,KAAU;AACpC,MAAIW,KAAK,GAAGL,UAAU,CAAC,CAAD,CAAtB;AAEAK,EAAAA,KAAK,CAACd,SAAS,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV,CAAL,GAA0BC,UAAU,CAAC,CAAD,EAAG,CAAH,CAApC;AACAa,EAAAA,KAAK,CAACd,SAAS,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV,CAAL,GAA0BM,UAAU,CAAC,CAAD,EAAG,CAAH,CAApC;AACAQ,EAAAA,KAAK,CAACd,SAAS,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV,CAAL,GAA0BM,UAAU,CAAC,CAAD,EAAG,CAAH,CAApC;AACAQ,EAAAA,KAAK,CAACd,SAAS,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV,CAAL,GAA0BM,UAAU,CAAC,CAAD,EAAG,CAAH,CAApC;AACAQ,EAAAA,KAAK,CAACd,SAAS,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAV,CAAL,GAA0BM,UAAU,CAAC,CAAD,EAAG,CAAH,CAApC;AAEA,SAAOQ,KAAP;AACD,CAVM","sourcesContent":["import { tileIndex } from './BoardFunctions';\n\n/*\n// Make pawn and king objects  \n*/\nconst makeP1Pawn = (i,j) => {\n  return {i, j, hasChecker: 1, king: false};\n}\n\nconst makeP2Pawn = (i,j) => {\n  return {i, j, hasChecker: -1, king: false};\n}\n\nconst makeP1King = (i,j) => {\n  return {i, j, hasChecker: 1, king: true};\n}\n\nconst makeP2King = (i,j) => {\n  return {i, j, hasChecker: -1, king: true};\n}\n\n/*\n// Define tiles with no checkers on them\n*/\nexport const emptyBoard = (boardSize) => {\n  let tile = []\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      tile.push({i, j, hasChecker: null});\n    }\n  }\n  return tile;\n}\n\n/*\n// Define tiles where p1 pawns remain and cant move, so p2 wins\n// Assumes a boardSize of 8\n*/\nexport const pawnCantMove = (i, j) => {\n  let tiles = emptyBoard(8);\n\n  tiles[tileIndex(3,3,8)] = makeP1Pawn(3,3);\n  tiles[tileIndex(4,2,8)] = makeP2Pawn(4,2);\n  tiles[tileIndex(6,0,8)] = makeP2Pawn(6,0);\n  tiles[tileIndex(4,4,8)] = makeP2Pawn(4,4);\n  tiles[tileIndex(5,5,8)] = makeP2Pawn(5,5);\n\n  return tiles;\n}"]},"metadata":{},"sourceType":"module"}