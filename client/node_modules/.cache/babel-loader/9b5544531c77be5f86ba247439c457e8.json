{"ast":null,"code":"// Define tiles with no checkers on them\nexport const emptyBoard = boardSize => {\n  let tile = [];\n\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      tile.push({\n        i,\n        j,\n        hasChecker: null\n      });\n    }\n  }\n\n  return tile;\n}; // Define tiles with start of game checkers arrangement\n\nexport const resetBoard = boardSize => {\n  let tile = [];\n\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      if (i <= boardSize / 3 && !getColor([i, j])) tile.push({\n        i,\n        j,\n        hasChecker: 1\n      });else if (i >= boardSize - boardSize / 3 - 1 && !getColor([i, j])) tile.push({\n        i,\n        j,\n        hasChecker: 2\n      });else tile.push({\n        i,\n        j,\n        hasChecker: null\n      });\n    }\n  }\n\n  return tile;\n}; // Determines what color a tile will be\n\nexport const getColor = coord => {\n  let i = coord[0];\n  let j = coord[1];\n  if ((i % 2 === 0 && j % 2 === 0) | (i % 2 === 1 && j % 2 === 1)) return 0;\n  return 1;\n}; // Check if proposed checker movement is legal\n\nconst isMoveValid = (tiles, oldCoord, newCoord, boardSize) => {\n  // oldCoord must not equal new coord\n  // oldCoord must contain a checker\n  if (!tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker) return false; // newCoord must contain no checker or opposing checker\n\n  if (tiles[newCoord[0] * boardSize + newCoord[1]] === tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker) return false; // newCoord must be diagonally adjacent, or with an opposing checker in between\n  // checker must move forward if its a single\n  // checker can move backward if its a king\n\n  return true;\n}; // Moves a checker from oldCoord to newCoord, returns updated tiles array\n\n\nexport const moveChecker = (tiles, oldCoord, newCoord, boardSize) => {\n  if (!isMoveValid(tiles, oldCoord, newCoord, boardSize)) return tiles;\n  console.log(\"tiles before: \", tiles);\n  tiles[newCoord[0] * boardSize + newCoord[1]] = {\n    i: newCoord[0],\n    j: newCoord[1],\n    hasChecker: tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker\n  };\n  tiles[oldCoord[0] * boardSize + oldCoord[1]] = {\n    i: oldCoord[0],\n    j: oldCoord[1],\n    hasChecker: null\n  };\n  console.log(\"tiles after: \", tiles);\n  return tiles;\n};","map":{"version":3,"sources":["/Users/haleyglavina/Desktop/code/checkers2/src/utils/BoardFunctions.js"],"names":["emptyBoard","boardSize","tile","i","j","push","hasChecker","resetBoard","getColor","coord","isMoveValid","tiles","oldCoord","newCoord","moveChecker","console","log"],"mappings":"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","sourcesContent":["// Define tiles with no checkers on them\nexport const emptyBoard = (boardSize) => {\n  let tile = []\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      tile.push({i, j, hasChecker: null});\n    }\n  }\n  return tile;\n}\n\n// Define tiles with start of game checkers arrangement\nexport const resetBoard = (boardSize) => {\n  let tile = []\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker]\n      if (i <= (boardSize / 3) && !getColor([i, j]))\n        tile.push({i, j, hasChecker: 1});\n      \n      else if (i >= (boardSize - (boardSize / 3) - 1) && !getColor([i, j])) \n        tile.push({i, j, hasChecker: 2});\n      \n      else \n        tile.push({i, j, hasChecker: null});\n    }\n  }\n  return tile;\n}\n\n// Determines what color a tile will be\nexport const getColor = (coord) => {\n  let i = coord[0]\n  let j = coord[1]\n\n  if (((i % 2 === 0) && (j % 2 === 0)) | ((i % 2 === 1) && (j % 2 === 1)))\n    return 0;\n  return 1;\n}\n\n// Check if proposed checker movement is legal\nconst isMoveValid = (tiles, oldCoord, newCoord, boardSize) => {\n  // oldCoord must not equal new coord\n\n  // oldCoord must contain a checker\n  if (!tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker)\n    return false;\n\n  // newCoord must contain no checker or opposing checker\n  if (tiles[(newCoord[0] * boardSize) + newCoord[1]] === tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker)\n    return false;\n\n  // newCoord must be diagonally adjacent, or with an opposing checker in between\n\n  // checker must move forward if its a single\n\n  // checker can move backward if its a king\n\n  return true;\n}\n\n// Moves a checker from oldCoord to newCoord, returns updated tiles array\nexport const moveChecker = (tiles, oldCoord, newCoord, boardSize) => {\n\n  if (!isMoveValid(tiles, oldCoord, newCoord, boardSize))\n    return tiles;\n    \n  console.log(\"tiles before: \", tiles);\n\n  tiles[(newCoord[0] * boardSize) + newCoord[1]] = {\n    i: newCoord[0], \n    j: newCoord[1], \n    hasChecker: tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker\n  };\n\n  tiles[(oldCoord[0] * boardSize) + oldCoord[1]] = {\n    i: oldCoord[0], \n    j: oldCoord[1], \n    hasChecker: null\n  };\n\n  console.log(\"tiles after: \", tiles);\n  return tiles;\n}"]},"metadata":{},"sourceType":"module"}