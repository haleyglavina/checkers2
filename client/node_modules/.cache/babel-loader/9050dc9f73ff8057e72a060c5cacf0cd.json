{"ast":null,"code":"export const tileIndex = (i, j, boardSize) => {\n  return i * boardSize + j;\n};\n/*\n// Define tiles with start of game checkers arrangement\n*/\n\nexport const resetBoard = boardSize => {\n  let tile = [];\n\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker, king]\n      if (i <= boardSize / 3 && !getColor([i, j])) tile.push({\n        i,\n        j,\n        hasChecker: 1,\n        king: false\n      });else if (i >= boardSize - boardSize / 3 - 1 && !getColor([i, j])) tile.push({\n        i,\n        j,\n        hasChecker: -1,\n        king: false\n      });else tile.push({\n        i,\n        j,\n        hasChecker: null,\n        king: false\n      });\n    }\n  }\n\n  return tile;\n};\n/*\n// Determines what color a tile will be\n*/\n\nexport const getColor = coord => {\n  let i = coord[0];\n  let j = coord[1];\n  if ((i % 2 === 0 && j % 2 === 0) | (i % 2 === 1 && j % 2 === 1)) return 0;\n  return 1;\n};\n/*\n// Check if proposed checker movement is legal\n*/\n\nconst isMoveValid = (tiles, oldCoord, newCoord, boardSize) => {\n  // oldCoord must not equal new coord\n  if (oldCoord[0] === newCoord[0] & oldCoord[1] === newCoord[1]) return false; // oldCoord must contain a checker\n\n  if (!tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker) return false; // newCoord must contain no checker\n\n  if (tiles[newCoord[0] * boardSize + newCoord[1]].hasChecker) return false; // SINGLES\n  // Moving a single in its forward direction by 1 is legal\n\n  let fwdDirection = tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker;\n  let iChangeValid = fwdDirection === 1 ? newCoord[0] === oldCoord[0] + 1 : newCoord[0] === oldCoord[0] - 1;\n  let jChangeValid = newCoord[1] === oldCoord[1] + 1 || newCoord[1] === oldCoord[1] - 1;\n\n  if (!tiles[oldCoord[0] * boardSize + oldCoord[1]].king) {\n    if (!(iChangeValid & jChangeValid)) return false;\n  } // KINGS\n  // Moving a king in its forward or backward direction by 1 is legal\n  else {\n    iChangeValid = newCoord[0] === oldCoord[0] + 1 || newCoord[0] === oldCoord[0] - 1;\n    if (!(iChangeValid & jChangeValid)) return false;\n  }\n\n  return true;\n};\n/*\n// Check if proposed checker move larger than an adjacent diagonal is legal\n*/\n\n\nconst isBigMoveValid = (tiles, oldCoord, newCoord, boardSize) => {\n  let oldTile = tiles[oldCoord[0] * boardSize + oldCoord[1]];\n  let fwdDirection = oldTile.hasChecker;\n  let iDirection = newCoord[0] > oldCoord[0] ? 1 : -1;\n  let jDirection = newCoord[1] > oldCoord[1] ? 1 : -1;\n  let iChangeValid = newCoord[0] === oldCoord[0] + 2 * fwdDirection;\n  let jChangeValid = newCoord[1] === oldCoord[1] + 2 || newCoord[1] === oldCoord[1] - 2;\n  let opponentCoord = [oldCoord[0] + fwdDirection, oldCoord[1] + jDirection];\n  let capturesOpponent = false;\n\n  if (oldTile.king) {\n    console.log(\"check move logic for a king\");\n    iChangeValid = newCoord[0] === oldCoord[0] + 2 || newCoord[0] === oldCoord[0] - 2;\n    opponentCoord = [oldCoord[0] + iDirection, oldCoord[1] + jDirection];\n    iChangeValid = newCoord[0] === oldCoord[0] + 2 || newCoord[0] === oldCoord[0] - 2;\n    let opponentTile = tiles[opponentCoord[0] * boardSize + opponentCoord[1]];\n    capturesOpponent = opponentTile.hasChecker === -1 * oldTile.hasChecker;\n  } else {\n    console.log(\"check move logic for a pawn\");\n    opponentCoord = [oldCoord[0] + fwdDirection, oldCoord[1] + jDirection];\n    capturesOpponent = fwdDirection === 1 ? tiles[opponentCoord[0] * boardSize + opponentCoord[1]].hasChecker === -1 : tiles[opponentCoord[0] * boardSize + opponentCoord[1]].hasChecker === 1;\n  } // SINGLES\n  // Moving a single in its forward direction by 2 is legal if it captures opponent\n\n\n  if (!oldTile.king) {\n    if (!(iChangeValid & jChangeValid & capturesOpponent)) return false;\n  } // KINGS\n  /// Moving a single in either direction by 2 is legal if it captures opponent\n  else {\n    iChangeValid = newCoord[0] === oldCoord[0] + 2 || newCoord[0] === oldCoord[0] - 2;\n    if (!(iChangeValid & jChangeValid & capturesOpponent)) return false;\n  }\n\n  return true;\n};\n/*\n// Removes an opponent's checker from the board\n*/\n\n\nconst moveCapturesOpponent = (tiles, oldCoord, newCoord, boardSize, updateScore) => {\n  let fwdDirection = tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker;\n  let jDirection = newCoord[1] > oldCoord[1] ? 1 : -1;\n  let opponentCoord = [oldCoord[0] + fwdDirection, oldCoord[1] + jDirection]; // SINGLES\n  // remove opponent\n\n  tiles[opponentCoord[0] * boardSize + opponentCoord[1]] = {\n    i: opponentCoord[0],\n    j: opponentCoord[1],\n    hasChecker: null,\n    king: false\n  }; // KINGS\n  // remove opponent\n\n  let iDirection = newCoord[0] > oldCoord[0] ? 1 : -1;\n  opponentCoord = [oldCoord[0] + iDirection, oldCoord[1] + jDirection];\n  tiles[opponentCoord[0] * boardSize + opponentCoord[1]] = {\n    i: opponentCoord[0],\n    j: opponentCoord[1],\n    hasChecker: null,\n    king: false\n  }; // increment point\n\n  let currPlayer = tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker;\n  updateScore(currPlayer === 1 ? [1, 0] : [0, 1]);\n  return tiles;\n};\n/*\n// Moves a checker from oldCoord to newCoord, returns updated tiles array\n*/\n\n\nexport const moveChecker = (tiles, oldCoord, newCoord, boardSize, updateScore) => {\n  if (isMoveValid(tiles, oldCoord, newCoord, boardSize)) {\n    console.log(\"valid small move\");\n  } else if (isBigMoveValid(tiles, oldCoord, newCoord, boardSize)) {\n    tiles = moveCapturesOpponent(tiles, oldCoord, newCoord, boardSize, updateScore);\n    console.log(\"valid big move\");\n  } else {\n    console.log(\"invalid move\");\n    return {\n      isValidMove: false,\n      tiles\n    };\n  }\n\n  tiles[newCoord[0] * boardSize + newCoord[1]] = {\n    i: newCoord[0],\n    j: newCoord[1],\n    hasChecker: tiles[oldCoord[0] * boardSize + oldCoord[1]].hasChecker,\n    king: isKing(tiles, oldCoord, newCoord, boardSize)\n  };\n  tiles[oldCoord[0] * boardSize + oldCoord[1]] = {\n    i: oldCoord[0],\n    j: oldCoord[1],\n    hasChecker: null,\n    king: false\n  };\n  console.log(\"returned tiles:\", tiles);\n  return {\n    isValidMove: true,\n    newTiles: tiles\n  };\n};\n/*\n// Returns true if a piece is already a king or should become one\n*/\n\nconst isKing = (tiles, oldCoord, newCoord, boardSize) => {\n  let oldTile = tiles[oldCoord[0] * boardSize + oldCoord[1]]; // if checker is already a king, return true\n\n  if (oldTile.king) return true; // conditions to become a king:\n  // if hasChecker is 1 (Chrome piece) and its new position is i=boardSize-1\n\n  if (oldTile.hasChecker === 1 & newCoord[0] === boardSize - 1) return true; // if hasChecker is -1 (IE piece) and its new position is i=0\n\n  if (oldTile.hasChecker === -1 & newCoord[0] === 0) return true;\n  return false;\n};\n/*\n// Check if current player cannot make any move. If so, current player has lost\n// Returns [if a player won, which player won]\n*/\n\n\nexport const checkForWin = (tiles, currPlayer, boardSize) => {\n  console.log(\"in check for win function\");\n  let nextPlayer = currPlayer * -1;\n  console.log(\"nextPlayer:\", nextPlayer);\n  let winResult = [false, null]; // loop thru tiles\n  // when we're on a p1 tile, it's a pawn, and fwd i direction has a valid move possibility\n  // break from loop\n  // when we're on a p1 tile, it's a king, and either i direction has a valid move possibility\n  // break from loop\n\n  for (let i = 0; i < tiles.length; i++) {\n    let oldCoord = [tiles[i].i, tiles[i].j];\n\n    if (tiles[i].hasChecker === nextPlayer) {\n      console.log(\"for the tile \", oldCoord, \"we're checking the following moves:\");\n      console.log(`[${tiles[i].i + tiles[i].hasChecker * 2}, ${tiles[i].j + 2}]`);\n      console.log(`[${tiles[i].i + tiles[i].hasChecker}, ${tiles[i].j + 1}]`);\n      console.log(`[${tiles[i].i + tiles[i].hasChecker * 2}, ${tiles[i].j - 2}]`);\n      console.log(`[${tiles[i].i + tiles[i].hasChecker}, ${tiles[i].j - 1}]`);\n      console.log(`[${tiles[i].i - tiles[i].hasChecker * 2}, ${tiles[i].j + 2}]`);\n      console.log(`[${tiles[i].i - tiles[i].hasChecker}, ${tiles[i].j + 1}]`);\n      console.log(`[${tiles[i].i - tiles[i].hasChecker * 2}, ${tiles[i].j - 2}]`);\n      console.log(`[${tiles[i].i - tiles[i].hasChecker}, ${tiles[i].j - 1}]`);\n\n      if ( // Check fwd direction moves\n      isMoveValid(tiles, oldCoord, [tiles[i].i + tiles[i].hasChecker, tiles[i].j + 1], boardSize) | isMoveValid(tiles, oldCoord, [tiles[i].i + tiles[i].hasChecker, tiles[i].j - 1], boardSize) | isMoveValid(tiles, oldCoord, [tiles[i].i + tiles[i].hasChecker * 2, tiles[i].j + 2], boardSize) | isMoveValid(tiles, oldCoord, [tiles[i].i + tiles[i].hasChecker * 2, tiles[i].j - 2], boardSize) | // Check backward direction moves\n      isMoveValid(tiles, oldCoord, [tiles[i].i - tiles[i].hasChecker, tiles[i].j + 1], boardSize) | isMoveValid(tiles, oldCoord, [tiles[i].i - tiles[i].hasChecker, tiles[i].j - 1], boardSize) | isMoveValid(tiles, oldCoord, [tiles[i].i - tiles[i].hasChecker * 2, tiles[i].j + 2], boardSize) | isMoveValid(tiles, oldCoord, [tiles[i].i - tiles[i].hasChecker * 2, tiles[i].j - 2], boardSize)) {\n        console.log(\"found a valid move, so leave checkForWin function\");\n        return winResult;\n      } else {\n        console.log(\"a player won bc of no more valid moves\");\n        return [true, currPlayer];\n      }\n    }\n  }\n\n  return winResult;\n};","map":{"version":3,"sources":["/Users/haleyglavina/Desktop/code/checkers2/client/src/utils/BoardFunctions.js"],"names":["tileIndex","i","j","boardSize","resetBoard","tile","getColor","push","hasChecker","king","coord","isMoveValid","tiles","oldCoord","newCoord","fwdDirection","iChangeValid","jChangeValid","isBigMoveValid","oldTile","iDirection","jDirection","opponentCoord","capturesOpponent","console","log","opponentTile","moveCapturesOpponent","updateScore","currPlayer","moveChecker","isValidMove","isKing","newTiles","checkForWin","nextPlayer","winResult","length"],"mappings":"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","sourcesContent":["export const tileIndex = (i, j, boardSize) => {\n  return (i * boardSize) + j;\n}\n\n/*\n// Define tiles with start of game checkers arrangement\n*/\nexport const resetBoard = (boardSize) => {\n  let tile = []\n  for (let i = 0; i < boardSize; i++) {\n    for (let j = 0; j < boardSize; j++) {\n      // [x, y, hasChecker, king]\n      if (i <= (boardSize / 3) && !getColor([i, j]))\n        tile.push({i, j, hasChecker: 1, king: false});\n      \n      else if (i >= (boardSize - (boardSize / 3) - 1) && !getColor([i, j])) \n        tile.push({i, j, hasChecker: -1, king: false});\n      \n      else \n        tile.push({i, j, hasChecker: null, king: false});\n    }\n  }\n  return tile;\n}\n\n/*\n// Determines what color a tile will be\n*/\nexport const getColor = (coord) => {\n  let i = coord[0]\n  let j = coord[1]\n\n  if (((i % 2 === 0) && (j % 2 === 0)) | ((i % 2 === 1) && (j % 2 === 1)))\n    return 0;\n  return 1;\n}\n\n/*\n// Check if proposed checker movement is legal\n*/\nconst isMoveValid = (tiles, oldCoord, newCoord, boardSize) => {\n  // oldCoord must not equal new coord\n    if ((oldCoord[0] === newCoord[0]) & (oldCoord[1] === newCoord[1]))\n      return false;\n\n  // oldCoord must contain a checker\n  if (!tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker)\n    return false;\n\n  // newCoord must contain no checker\n  if (tiles[(newCoord[0] * boardSize) + newCoord[1]].hasChecker)\n    return false;\n\n  // SINGLES\n  // Moving a single in its forward direction by 1 is legal\n  let fwdDirection = tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker;\n  let iChangeValid = fwdDirection === 1 ? (newCoord[0] === (oldCoord[0] + 1)) : (newCoord[0] === (oldCoord[0] - 1));\n  let jChangeValid = ((newCoord[1] === (oldCoord[1] + 1)) || (newCoord[1] === (oldCoord[1] - 1)));\n\n  if (!tiles[(oldCoord[0] * boardSize) + oldCoord[1]].king) {\n    if (!(iChangeValid & jChangeValid))\n      return false;\n  }\n\n  // KINGS\n  // Moving a king in its forward or backward direction by 1 is legal\n  else {\n    iChangeValid = ((newCoord[0] === (oldCoord[0] + 1)) || (newCoord[0] === (oldCoord[0] - 1)));\n\n    if (!(iChangeValid & jChangeValid))\n      return false;\n  }\n\n  return true;\n}\n\n/*\n// Check if proposed checker move larger than an adjacent diagonal is legal\n*/\nconst isBigMoveValid = (tiles, oldCoord, newCoord, boardSize) => {\n\n  let oldTile = tiles[(oldCoord[0] * boardSize) + oldCoord[1]];\n\n  let fwdDirection = oldTile.hasChecker;\n  let iDirection = newCoord[0] > oldCoord[0] ? 1 : -1;\n  let jDirection = newCoord[1] > oldCoord[1] ? 1 : -1;\n  let iChangeValid = newCoord[0] === (oldCoord[0] + (2 * fwdDirection));\n  let jChangeValid = ((newCoord[1] === (oldCoord[1] + 2)) || (newCoord[1] === (oldCoord[1] - 2)));\n  let opponentCoord = [oldCoord[0] + fwdDirection, oldCoord[1] + jDirection];\n  let capturesOpponent = false;\n\n  if (oldTile.king) {\n    console.log(\"check move logic for a king\")\n    iChangeValid = ((newCoord[0] === (oldCoord[0] + 2)) || (newCoord[0] === (oldCoord[0] - 2)));\n    opponentCoord = [ oldCoord[0] + iDirection, oldCoord[1] + jDirection ];\n    iChangeValid = ((newCoord[0] === (oldCoord[0] + 2)) || (newCoord[0] === (oldCoord[0] - 2)));\n    let opponentTile = tiles[(opponentCoord[0] * boardSize) + opponentCoord[1]];\n    capturesOpponent = (opponentTile.hasChecker === (-1 * oldTile.hasChecker));\n  } else {\n    console.log(\"check move logic for a pawn\")\n    opponentCoord = [oldCoord[0] + fwdDirection, oldCoord[1] + jDirection];\n    capturesOpponent = (fwdDirection === 1 \n      ? (tiles[(opponentCoord[0] * boardSize) + opponentCoord[1]].hasChecker === -1) \n      : (tiles[(opponentCoord[0] * boardSize) + opponentCoord[1]].hasChecker === 1));\n  }\n\n  // SINGLES\n  // Moving a single in its forward direction by 2 is legal if it captures opponent\n  if (!oldTile.king) {\n    if (!(iChangeValid & jChangeValid & capturesOpponent))\n      return false; \n  }\n\n  // KINGS\n  /// Moving a single in either direction by 2 is legal if it captures opponent\n  else {\n    iChangeValid = ((newCoord[0] === (oldCoord[0] + 2)) || (newCoord[0] === (oldCoord[0] - 2)));\n\n    if (!(iChangeValid & jChangeValid & capturesOpponent))\n      return false;\n  }\n\n  return true;\n\n}\n/*\n// Removes an opponent's checker from the board\n*/\nconst moveCapturesOpponent = (tiles, oldCoord, newCoord, boardSize, updateScore) => {\n\n  let fwdDirection = tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker;\n  let jDirection = newCoord[1] > oldCoord[1] ? 1 : -1;\n  let opponentCoord = [oldCoord[0] + fwdDirection, oldCoord[1] + jDirection];\n\n  // SINGLES\n  // remove opponent\n  tiles[(opponentCoord[0] * boardSize) + opponentCoord[1]] = {\n    i: opponentCoord[0], \n    j: opponentCoord[1], \n    hasChecker: null,\n    king: false\n  };\n\n  // KINGS\n  // remove opponent\n  let iDirection = newCoord[0] > oldCoord[0] ? 1 : -1;\n  opponentCoord = [ oldCoord[0] + iDirection, oldCoord[1] + jDirection ];\n  tiles[(opponentCoord[0] * boardSize) + opponentCoord[1]] = {\n    i: opponentCoord[0], \n    j: opponentCoord[1], \n    hasChecker: null,\n    king: false\n  };\n\n  // increment point\n  let currPlayer = tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker;\n  updateScore(currPlayer === 1 ? [1, 0] : [0, 1])\n\n  return tiles;\n}\n\n/*\n// Moves a checker from oldCoord to newCoord, returns updated tiles array\n*/\nexport const moveChecker = (tiles, oldCoord, newCoord, boardSize, updateScore) => {\n\n  if (isMoveValid(tiles, oldCoord, newCoord, boardSize)) {\n    console.log(\"valid small move\");\n  } else if (isBigMoveValid(tiles, oldCoord, newCoord, boardSize)) {\n    tiles = moveCapturesOpponent(tiles, oldCoord, newCoord, boardSize, updateScore);\n    console.log(\"valid big move\");\n  } else {\n    console.log(\"invalid move\");\n    return {isValidMove: false, tiles};\n  }\n\n  tiles[(newCoord[0] * boardSize) + newCoord[1]] = {\n    i: newCoord[0], \n    j: newCoord[1], \n    hasChecker: tiles[(oldCoord[0] * boardSize) + oldCoord[1]].hasChecker,\n    king: isKing(tiles, oldCoord, newCoord, boardSize)\n  };\n\n  tiles[(oldCoord[0] * boardSize) + oldCoord[1]] = {\n    i: oldCoord[0], \n    j: oldCoord[1], \n    hasChecker: null,\n    king: false\n  };\n\n  console.log(\"returned tiles:\", tiles);\n  return {isValidMove: true, newTiles: tiles};\n}\n\n/*\n// Returns true if a piece is already a king or should become one\n*/\nconst isKing = (tiles, oldCoord, newCoord, boardSize) => {\n  let oldTile = tiles[(oldCoord[0] * boardSize) + oldCoord[1]];\n\n  // if checker is already a king, return true\n  if (oldTile.king)\n    return true;\n\n  // conditions to become a king:\n  // if hasChecker is 1 (Chrome piece) and its new position is i=boardSize-1\n  if ((oldTile.hasChecker === 1) & (newCoord[0] === (boardSize - 1)))\n    return true;\n  // if hasChecker is -1 (IE piece) and its new position is i=0\n  if ((oldTile.hasChecker === -1) & (newCoord[0] === 0))\n    return true;\n\n  return false;\n}\n\n/*\n// Check if current player cannot make any move. If so, current player has lost\n// Returns [if a player won, which player won]\n*/\nexport const checkForWin = (tiles, currPlayer, boardSize) => {\n  console.log(\"in check for win function\");\n\n  let nextPlayer = currPlayer * -1;\n  console.log(\"nextPlayer:\", nextPlayer);\n\n  let winResult = [false, null];\n  // loop thru tiles\n    // when we're on a p1 tile, it's a pawn, and fwd i direction has a valid move possibility\n    // break from loop\n\n    // when we're on a p1 tile, it's a king, and either i direction has a valid move possibility\n    // break from loop\n\n  for (let i=0; i < tiles.length; i++) {\n    let oldCoord = [tiles[i].i, tiles[i].j];\n\n    if (tiles[i].hasChecker === nextPlayer) {\n      console.log(\"for the tile \", oldCoord, \"we're checking the following moves:\");\n      console.log(`[${tiles[i].i + (tiles[i].hasChecker * 2)}, ${tiles[i].j + 2}]`);\n      console.log(`[${tiles[i].i + (tiles[i].hasChecker)}, ${tiles[i].j + 1}]`);\n      console.log(`[${tiles[i].i + (tiles[i].hasChecker * 2)}, ${tiles[i].j - 2}]`);\n      console.log(`[${tiles[i].i + (tiles[i].hasChecker)}, ${tiles[i].j - 1}]`);\n      console.log(`[${tiles[i].i - (tiles[i].hasChecker * 2)}, ${tiles[i].j + 2}]`);\n      console.log(`[${tiles[i].i - (tiles[i].hasChecker)}, ${tiles[i].j + 1}]`);\n      console.log(`[${tiles[i].i - (tiles[i].hasChecker * 2)}, ${tiles[i].j - 2}]`);\n      console.log(`[${tiles[i].i - (tiles[i].hasChecker)}, ${tiles[i].j - 1}]`);\n\n\n      if ( // Check fwd direction moves\n        (isMoveValid(tiles, oldCoord, [tiles[i].i + (tiles[i].hasChecker), tiles[i].j + 1], boardSize)) | \n        (isMoveValid(tiles, oldCoord, [tiles[i].i + (tiles[i].hasChecker), tiles[i].j - 1], boardSize)) |\n        (isMoveValid(tiles, oldCoord, [tiles[i].i + (tiles[i].hasChecker * 2), tiles[i].j + 2], boardSize)) |  \n        (isMoveValid(tiles, oldCoord, [tiles[i].i + (tiles[i].hasChecker * 2), tiles[i].j - 2], boardSize)) | \n        // Check backward direction moves\n        (isMoveValid(tiles, oldCoord, [tiles[i].i - (tiles[i].hasChecker), tiles[i].j + 1], boardSize)) | \n        (isMoveValid(tiles, oldCoord, [tiles[i].i - (tiles[i].hasChecker), tiles[i].j - 1], boardSize)) | \n        (isMoveValid(tiles, oldCoord, [tiles[i].i - (tiles[i].hasChecker * 2), tiles[i].j + 2], boardSize)) | \n        (isMoveValid(tiles, oldCoord, [tiles[i].i - (tiles[i].hasChecker * 2), tiles[i].j - 2], boardSize))) {\n        console.log(\"found a valid move, so leave checkForWin function\");\n        return winResult;\n      } else {\n        console.log(\"a player won bc of no more valid moves\");\n        return [true, currPlayer];\n      }\n    }\n  }\n\n  return winResult;\n}"]},"metadata":{},"sourceType":"module"}